package eplccode

import (
	"encoding/json"
	"eplc/src/libepl/eplparse/ast"
	"eplc/src/libepl/eplparse/symboltable"
	"fmt"
	"os"
	"path"
	"strings"
)

func CreateLabel(index uint, command string, argOne string, argTwo string) Label {
	return Label{index, command, argOne, argTwo}
}

type Label struct {
	index   uint
	command string
	argOne  string
	argTwo  string
}

func (l *Label) asString() string {
	return fmt.Sprintf("L%d: %s %s, %s\n", l.index, l.command, l.argOne, l.argTwo)
}

type Writer struct {
	Fname      string
	path 	   string
	targetFile *os.File
	TargetName string
	Labels     []Label
}

func (w *Writer) InitializeWriter() {
	w.TargetName = strings.Split(w.Fname, ".")[0] + ".air"
	file, _ := os.Create(w.TargetName)

	base := path.Base(w.Fname)

	if base == w.Fname {
		w.path = "."
	} else {
		w.path = strings.Replace(w.Fname, base, "", -1)
	}

	_, _ = file.WriteString("#Generated by epl compiler\n")
	_, _ = file.WriteString("![arch=x86]\n![opt_level=1]\n![build_type=release]\n")
	w.targetFile = file
}

func (w *Writer) WriteToTarget() {
	defer w.targetFile.Close()
	for _, lb := range w.Labels {
		_, _ = w.targetFile.WriteString(lb.asString())
	}
}

func (w *Writer) UpdateLabels(labels []Label) {
	for _, lb := range labels {
		w.Labels = append(w.Labels, lb)
	}
}

func (w *Writer) UpdateLabel(label Label) {
	w.Labels = append(w.Labels, label)
}

func (w *Writer) ProduceST(st *symboltable.SymbolTable) {
	b, err := json.MarshalIndent(*st, "", "\t")

	if err != nil {

	} else {
		file, _ := os.Create(w.path+"SymbolTable.json")
		_, _ = file.Write(b)
	}
}

func (w *Writer) ProduceAST(ast ast.Node) {
	b, err := json.MarshalIndent(ast, "", "\t")

	if err != nil {

	} else {
		file, _ := os.Create(w.path+"SyntaxTree.json")
		_, _ = file.Write(b)
	}
}
