package eplccode

import (
	"encoding/json"
	"eplc/src/libepl/eplparse/symboltable"
	"fmt"
	"os"
	"strings"
)

func CreateLabel(index uint, command string, argOne string, argTwo string) Label {
	return Label{index, command, argOne, argTwo}
}
type Label struct {
	index uint
	command string
	argOne string
	argTwo string
}
func (l *Label) asString() string {
	return fmt.Sprintf("L%d: %s %s, %s\n", l.index, l.command, l.argOne, l.argTwo)
}

type Writer struct {
	Fname string
	targetFile *os.File
	TargetName string
	Labels []Label
}

func (w *Writer) InitializeWriter() {
	fmt.Println(w.Fname)
	w.TargetName = strings.Split(w.Fname, ".")[0]+".bin"
	 file, _ := os.Create(w.TargetName)

	_, _ = file.WriteString("#Generated by epl compiler\n")
	 w.targetFile = file
}

func (w *Writer) WriteToTarget() {
	defer w.targetFile.Close()
	for _, lb := range w.Labels {
		_, _ = w.targetFile.WriteString(lb.asString())
	}
}

func (w *Writer) UpdateLabels(labels []Label) {
	for _, lb := range labels{
		w.Labels = append(w.Labels, lb)
	}
}


func (w *Writer) UpdateLabel(label Label) {
	w.Labels = append(w.Labels, label)
}

func (w *Writer) produceST(st *symboltable.SymbolTable) {
	b, err := json.Marshal(st)

	if err != nil {

	} else {
		file, _ := os.Create("SymbolTable.json")
		_, _ = file.Write(b)
	}
}